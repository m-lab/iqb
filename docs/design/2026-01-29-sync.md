# Sync Optimization

**Date:** 2026-01-29
**Status:** Implemented (ThreadPoolExecutor + JSONL metrics in `iqb cache pull`, PR #141)

## Problem

Syncing all cache files from GCS is slow when downloads happen
sequentially. The metric that matters is total wall-clock time from
"start sync" to "all files ready," not per-file download time.

## Decision: ThreadPoolExecutor

Three parallelization approaches were considered:

- **ThreadPoolExecutor** — wrap existing download code in threads.
  Minimal changes; `urllib`/`requests` are thread-safe and the GIL
  releases during I/O.
- **asyncio + aiohttp** — true concurrency but async "infects" callers,
  requiring a larger rewrite.
- **Download service with queue** — explicit worker pool with retry and
  rate limiting, but a bigger refactor for uncertain benefit.

ThreadPoolExecutor was chosen for simplicity. It parallelizes downloads
with no architectural changes to the existing code.

## Decision: JSONL Spans Instead of OpenTelemetry

Tracing (spans with start/end times per file) is more useful than
aggregate metrics for diagnosing sync performance — a waterfall view
immediately shows whether downloads are sequential or parallel and
which files dominate the time.

OpenTelemetry was evaluated and rejected: the SDK is lightweight
(~240 KB) but adds a dependency for a narrow use case. Instead,
`iqb cache pull` writes one JSONL file per invocation to
`.iqb/state/logs/`, with one span per downloaded file. Always-on,
no opt-in, no new dependencies.

